All signals are defined in library ``signal.h`` in C Standard Library.

## Linux signal

The C standard defines only 6 signals. They are all defined as macro in ``signal.h`` header (``csignal`` header in C++):

* ``SIGABRT`` (Signal Abort): Abnormal termination, such as is initiated by the function.
* ``SIGFPE`` (Signal Floating-Point Exception): Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).
* ``SIGILL`` (Signal Illegal Instruction): Invalid function image, such as an illegal instruction. This is generally due to a corruption in the code or to an attempt to execute data.
* ``SIGINT`` (Signal Interrupt): Interactive attention signal. Generally generated by the application user, like ``Ctr+C``
* ``SIGSEGV`` (Signal Segmentation Violation): Invalid access to storage âˆ’ When a program tries to read or write outside the memory it is allocated for it.
* ``SIGTERM`` (Signal Terminate): Termination request sent to program.

``Unix`` and ``Unix-like`` operating systems (such as Linux) define more than 15 additional signals

```
1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
```

``SIGUSR1`` and ``SIGUSR2`` are user defined signal

``SIGQUIT``: ``SIGQUIT`` signal is similar to ``SIGINT``

``SIGTSTP``: Stop a process, mapped to ``Ctr+Z``

``SIGWINCH``: a signal sent upon the resizing of a window. When the number of columns or rows changes, ``SIGWINCH`` is raised to the foreground processes attached to the terminal.

``SIGKILL``: immediately terminate a process, ``SIGKILL`` cannot be caught, handled or ignored. It is impossible to block this signal.

``SIGTERM``: politely ask a program to terminate. Unlike SIGKILL, this signal can be blocked, handled, and ignored.

## API

### kill()

```c
int kill(pid_t pid, int sig);
```
Send signal (``sig``) to a process specified by ``pid``.

### signal()

``signal()``: sets a function to handle signal

```c
sighandler_t signal(int signum, sighandler_t signal_handler);
```

* ``signum``: The signal number to which a handling function is set.
* ``signal_handler``: The ``signal_handler`` function has prototype

```c
void signal_handler(int signal_number);
```

``signal_handler()`` runs asynchronously, it can interrupt the program at any point. Some functions are listed a async-signal-safe, which includes ``write()``, not ``printf()``. So using ``printf()`` is not recommended and may cause the program with signal to crash in some case.

### sigaction()

```c
int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact);
```

* ``act``: If act is non-NULL, the new action for signal ``signum`` is installed from ``act``.
* ``oldact``: If oldact is non-NULL, the previous action is saved in ``oldact``.

```c
struct sigaction {
               void     (*sa_handler)(int);
               void     (*sa_sigaction)(int, siginfo_t *, void *);
               sigset_t   sa_mask;
               int        sa_flags;
               void     (*sa_restorer)(void);
};
```

* ``sa_mask``: A mask of signals which should be blocked
* ``sa_flags``: A set of flags which modify the behavior of the signal.

Data type ``sigset_t`` represents a set of signals. Check [process signal mask document](Process%20signal%20mask.md) for implementation to form ``sigset_t`` object.

Signal handler function can be used with ``sa_sigaction`` to handle parameters:

To use ``sa_sigaction`` and get the parameter successfully in ``sa_sigaction`` function handler, flag ``SA_SIGINFO`` must be used.

```c

/*
    ucontext: This is a pointer to a ucontext_t structure, cast to
              void *.  The structure pointed to by this field contains
              signal context information that was saved on the user-
              space stack by the kernel
*/
void signal_action_handler(int signal_number, siginfo_t *siginfo, void *ucontext){
	//Operations go here
}

int main(){
	struct sigaction sa;
    sa.sa_sigaction = &signal_action_handler;
    sa.sa_flags = SA_SIGINFO;

    sigaction(SIGUSR1, &sa, NULL);
}
```

The ``siginfo_t`` data type is a structure with many members inside. ``union sigval si_value`` is included for ``sigqueue sigval``

```c
siginfo_t {
	int      si_signo;     /* Signal number */
	int      si_errno;     /* An errno value */

	//Other mmembers are ommitted

	pid_t    si_pid;       /* Sending process ID */
	uid_t    si_uid;       /* Real user ID of sending process */
	union sigval si_value; /* Signal value */
	int      si_int;       /* POSIX.1b signal */
	void    *si_ptr;       /* POSIX.1b signal */
	
	//Other mmembers are ommitted
}
```

### sigqueue()

Queue a signal and data to a process

```c
int sigqueue(pid_t pid, int sig, const union sigval value);
```

```c
union sigval {
	int   sival_int;
	void *sival_ptr;
};
```

``sigqueue()`` can be used to send parameter to other process that handles the signal.
